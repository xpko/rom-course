# 安卓系统定制：从入门到实践

## 第1章 引言
### 1.1 AOSP是什么
### 1.2 系统开发，定制，刷机，改机分别是什么
### 1.3 安卓系统发展史
### 1.4 常见的第三方定制系统
### 1.5 初识系统定制
### 1.5.1 系统定制的优点
### 1.5.2 系统定制的缺点
### 1.5.3 系统定制的发展趋势
### 1.6 初识系统刷机
### 1.7 小结

## 第2章 系统开发环境与工具
### 2.1 重新看待系统定制
### 2.2 环境准备
### 2.2.1 Windows环境
### 2.2.2 Linux环境
### 2.3 源码拉取与同步
#### 2.3.1 分支选择策略
#### 2.3.2 repo配置
#### 2.3.3 源码拉取与同步
### 2.4 系统编译
#### 2.4.1 AOSP编译依赖库安装
#### 2.4.2 系统编译
### 2.5 模块编译
### 2.6 内核编译
### 2.7 刷机
#### 2.7.1 线刷
#### 2.7.2 卡刷
### 2.8 源码的开发环境搭建
### 2.9 gitlab配合repo管理源码
### 2.10 小结

## 第3章 认识系统组件
### 3.1 源码结构介绍
### 3.2 Android的启动流程
### 3.3 内核启动
### 3.4 init进程启动
### 3.5 init.rc
### 3.6 Zygote启动
### 3.7 应用启动
### 3.8 认识services
### 3.9 认识framework
### 3.10 认识libcore
### 3.11 认识sepolicy
### 3.12 认识linker

## 第4章 系统美化
### 4.1 系统美化简介
### 4.2 常见的系统美化方式
### 4.3 主题修改
### 4.3.1 认识framework-res
### 4.3.2 编译framework-res
### 4.4 修改开机画面
### 4.5 修改字体
### 4.6 修改壁纸
### 4.7 修改图标
### 4.8 美化包使用

## 第5章 系统内置功能
### 5.1 什么是系统内置
### 5.2 系统内置app
### 5.3 构建系统
### 5.4 系统内置jar库
### 5.5 系统内置so动态库
### 5.6 系统内置证书
### 5.7 修改testkey
### 5.8 默认开启adb调试

## 第6章 功能定制
### 6.1 如何进行功能定制
### 6.2 插桩
### 6.2.1 静态插桩
### 6.2.2 动态插桩
### 6.2.3 ROM插桩
### 6.3 RegisterNative插桩
### 6.3.1 Native函数注册
### 6.3.2 RegisterNative执行流程
### 6.3.3 RegisterNative实现插桩
### 6.4 自定义系统服务
### 6.5 APP权限修改
### 6.5.1 APP权限介绍
### 6.5.2 权限解析源码跟踪
### 6.5.3 修改APP默认权限
### 6.6 进程注入
### 6.6.1 注入时机的选择
### 6.6.2 注入jar包
### 6.7 本章小结
## 第7章 类加载和函数调用
### 7.1 双亲委派机制
### 7.2 类的加载流程
### 7.3 函数调用流程
### 7.4 ExecuteMterpImpl
### 7.5 ExecuteSwitch

## 第8章 脱壳
### 8.1 壳，加壳，脱壳
### 8.1.1 什么是加壳
### 8.1.2 如何脱壳
### 8.2 壳的特征
### 8.3 动态加载壳的实现
### 8.4 如何脱壳
### 8.5 自动脱壳机

## 第9章 Android Hook框架
### 9.1 Xposed
### 9.2 Xposed实现原理
### 9.3 常见的Hook框架
### 9.4 集成pine
### 9.5 集成dobby
### 9.6 实战测试

## 第10章 系统集成开发eBPF
### 10.1 什么是eBPF
### 10.2 什么是bcc
### 10.3 安卓系统中使用bcc
### 10.3.1 为系统打上补丁
### 10.3.2 测试eBPF使能
### 10.4 使用eBPF实现安卓系统进程跟踪

## 第11章 反调试
### 11.1 反调试常见手段
### 11.2 常见反调试绕过方案
### 11.3 系统层面解决反调试
### 11.4 集成反反调试功能

## 第12章 基于定制系统的逆向实战
### 12.1 案例1
### 12.2 案例2
### 12.3 小结
